# BDDDG  --- BDDを単純直交分解した結果を表すクラス

ヘッダーファイル名: "BDDDG.h"  
ソースファイル名: BDDDG.cc  
内部から呼び出しているクラス: BDD, BDDV

BDDを単純直交分解により、acyclic な回路表現を生成するクラス。
分解結果はDDGというグラフ構造で保持し、各節点の種類（端子、定数、AND, OR, 
XOR, OTHER）、入力エッジのリスト（最大２つまで）、セレクタ変数集合などの情報を
持っている。セレクタ変数が変化したとき、出力値も変化する可能性があり、それに
従って列挙することで古典的な単純直交分解を求めることができる。BtoI など他のクラスからも
同様のデータ構造として扱える。

### 公開クラスメソッド

### BDDDG

```cpp
BDDDG::BDDDG(void)
```

constructer。初期値として空のBDDDGオブジェクトを生成する。
DDGには何も登録されていない。

### ~BDDDG

```cpp
BDDDG::~BDDDG(void)
```

destructer。

### Decomp

```cpp
int BDDDG::Decomp(BDD f)
```

関数 f の単純分解を行い、DDGを生成する。DDGのノード番号を返す。
セレクタの変数の組合せを、0, 1, 2, ... と順に試して、最初に
２つ以下の相異なる論理関数（コファクタ）を見つけると、その節点は
端子、定数もしくは線形関数（AND, OR, XOR）として登録され、それ以外
は非線形（OTHER）としてセレクタ節点が挿入される。
記憶あふれの場合や f がnull のときは、-1を返す。

### Decomp2

```cpp
int BDDDG::Decomp2(BDD f)
```

関数 f の単純分解を行い、DDGを生成する。DDGのノード番号を返す。
セレクタの変数の組合せを、最上位、次上位、とようにしてなるべく
小さい個数の変数で掃引することを試みる。他の点は Decomp(f)と同じ。
記憶あふれの場合や f がnull のときは、-1を返す。

### DecompAll

```cpp
int BDDDG::DecompAll(BDD f)
```

関数 f の単純分解を行い、DDGを生成する。DDGのノード番号を返す。
コファクタの個数に関わらず全ての変数組合せを調べ、コファクタ数が
最小となる変数組合せを求める。コファクタ数が２つ以下ならば線形関数
（演算の種類 AND, OR, XOR）に分解され、そうでなければ非線形（他の演算 OTHER）
として扱われる。記憶あふれの場合や f がnull のときは、-1を返す。

### DecompITE

```cpp
int BDDDG::DecompITE(BDD f)
```

関数 f の ITE (if-then-else) 分解を行い、DDGを生成する。DDGのノード番号を返す。
分解は最上位の変数から開始し、f_0, f_1 という２つの部分関数が生成される。
部分関数 f_0, f_1 についても同様に分解を繰り返す。終端ノードとなるのは
定数のみである。他の単純分解と異なり、全ての節点は非線形関数（OTHERタイプ）
となり、セレクタ集合は必ず変数１つとなる。記憶あふれの場合や f がnull の
ときは、-1を返す。

### DecompSOP

```cpp
int BDDDG::DecompSOP(BDD f)
```

関数 f の積和形分解を行い、DDGを生成する。DDGのノード番号を返す。
まず積項を構成する各変数リテラルをANDで結合する節点を作り、その後
各積項をORで結合する回路を作る。２段論理回路構造として表現される。
記憶あふれの場合や f がnull のときは、-1を返す。

### DecompESOP

```cpp
int BDDDG::DecompESOP(BDD f)
```

関数 f の排他的積和形分解を行い、DDGを生成する。DDGのノード番号を返す。
まず積項を構成する各変数リテラルをANDで結合する節点を作り、その後
各積項をXORで結合する回路を作る。２段論理回路構造として表現される。
記憶あふれの場合や f がnull のときは、-1を返す。

### TopNode

```cpp
int BDDDG::TopNode(void) const
```

DDG の出力節点番号（最後に分解した関数に対応する節点）を返す。
TopNode は必ずしも節点番号の最大値ではない。
null のときは、-1を返す。

### PrintCore

```cpp
void BDDDG::PrintCore(void) const
```

DDGの節点情報を標準出力に出力する。

### Print

```cpp
void BDDDG::Print(FILE *strm = stdout, int is_CSoP = 0) const
```

分解結果の論理構造を、RPNJ(Reverse Polish Notation with Jumping)という
表現形式で書き出す。is_CSOPフラグが１のときには積和形式（CSS形式）で出力する。
stmで指定したファイルストリームに出力する。
１行目はDDGノードの個数、２行目がルートノード番号、最下位ビット番号、最大または
最小ビットインデックスを書く。３行目以降は各ノードの記述である。出力形式は
以下のようなコンパクトな表現となっている。

(例)
10
4 0 5 
0 0 0 0 0 
1 0 0 0 0 
2 1 1 0 0 "x[1]"
3 1 2 0 0 "x[2]"
4 1 3 0 0 "x[3]"
5 2 1 2 0 
6 3 5 3 0 
7 3 6 4 0 
8 3 7 3 0 
9 3 2 8 0 

ただし、各行の先頭は各節点のノード番号であり、２列目はノードタイプの番号
（0: 定数０, 1: 定数１, 2: 端子, 3: AND, 4: OR, 5: XOR, 6: OTHER）、
３，４列目はそれぞれ入力エッジの接続先のノード番号、５列目はセレクタ変数の
集合を表す節点番号、さらに端子の場合は入力変数名を表す文字列が続く。

---

## LCM関連の関数

### CtoI_LcmC

```cpp
CtoI CtoI_LcmC(char *fname1, char *fname2, int th)
```

fname1で指定する名前のファイルからFIMIベンチマークフォーマットのトランザクションデータベースを読み込み、LCMアルゴリズムを用いて、閾値 th 回以上出現する飽和頻出アイテム集合を表す CtoIオブジェクトを生成し、それを返す。fname2にNULL以外が指定された場合は、変数順序ファイルを読み込んで、その順序でLCMを実行する。記憶あふれの場合は null を返す。ファイル読み込みに失敗した場合はエラーメッセージを出力する。（LCM関連のメソッドは別途インストールする必要あり）

### CtoI_LcmM

```cpp
CtoI CtoI_LcmM(char *fname1, char *fname2, int th)
```

fname1で指定する名前のファイルからFIMIベンチマークフォーマットのトランザクションデータベースを読み込み、LCMアルゴリズムを用いて、閾値 th 回以上出現する極大頻出アイテム集合を表す CtoIオブジェクトを生成し、それを返す。fname2にNULL以外が指定された場合は、変数順序ファイルを読み込んで、その順序でLCMを実行する。記憶あふれの場合は null を返す。ファイル読み込みに失敗した場合はエラーメッセージを出力する。（LCM関連のメソッドは別途インストールする必要あり）

### CtoI_LcmCV

```cpp
CtoI CtoI_LcmCV(char *fname1, char *fname2, int th)
```

CtoI_LcmCとほとんど同じだが、それぞれのアイテム組合せの出現回数を保持したCtoIオブジェクトを生成し、それを返す。（LCM関連のメソッドは別途インストールする必要あり）

### CtoI_LcmMV

```cpp
CtoI CtoI_LcmMV(char *fname1, char *fname2, int th)
```

CtoI_LcmMとほとんど同じだが、それぞれのアイテム組合せの出現回数を保持したCtoIオブジェクトを生成し、それを返す。（LCM関連のメソッドは別途インストールする必要あり）

### CtoI_Lcm

```cpp
CtoI CtoI_Lcm(char *fname1, char *fname2, int th)
```

fname1で指定する名前のファイルからFIMIベンチマークフォーマットのトランザクションデータベースを読み込み、LCMアルゴリズムを用いて、閾値 th 回以上出現する頻出アイテム集合を表す CtoIオブジェクトを生成し、それを返す。fname2にNULL以外が指定された場合は、変数順序ファイルを読み込んで、その順序でLCMを実行する。記憶あふれの場合は null を返す。ファイル読み込みに失敗した場合はエラーメッセージを出力する。（LCM関連のメソッドは別途インストールする必要あり）

---

